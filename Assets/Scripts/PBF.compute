RWStructuredBuffer<float3> gPosition;
RWStructuredBuffer<float3> gPredictionPosition;
RWStructuredBuffer<float3> gVelocity;

uniform uint gParticlesNumber;
uniform uint gBlockSize;

#define MAX_THREAD_X 1024
#define DELTA_T  0.01667
#define INV_DELTA_T 60

#pragma kernel ApplyForce
[numthreads(MAX_THREAD_X, 1, 1)]
void ApplyForce(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] += DELTA_T * float3(0, -9.8f, 0);
        gPredictionPosition[id] = gPosition[id] + DELTA_T * gVelocity[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePositionAndVelocity
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePositionAndVelocity(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] = INV_DELTA_T * (gPredictionPosition[id] - gPosition[id]);
        gPosition[id] = gPredictionPosition[id];
        //TODO:

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float3> gWallsNormal;
RWStructuredBuffer<float3> gWallsPosition;

uniform float gRadius;
uniform uint gWallSize;

#pragma kernel HandleCollision
[numthreads(MAX_THREAD_X, 1, 1)]
void HandleCollision(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;

    while (id < gParticlesNumber) {
        for (int i = 0; i < gWallSize; ++i) {
            float3 n = gWallsNormal[i];
            float3 p = gWallsPosition[i];
            float sdf = dot(gPredictionPosition[id] - p, n) - gRadius;
            if (sdf < 0) {
                gPredictionPosition[id] -= sdf * n;
                gVelocity[id] -= (sdf * n) * INV_DELTA_T;
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<int> gNeighbors;

uniform uint gMaxNeighborsCount;
uniform float gKernelRange;

#pragma kernel GetNeighbors
[numthreads(MAX_THREAD_X, 1, 1)]
void GetNeighbors(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        int countID = id * gMaxNeighborsCount;
        gNeighbors[countID] = 0;
        for (int i = 0; i < gParticlesNumber; ++i) {
            if (i != id) {
                float3 subVec = gPredictionPosition[i] - gPredictionPosition[id];
                float dis2 = dot(subVec, subVec);
                if (dis2 <= gKernelRange * gKernelRange) {
                    ++gNeighbors[countID];
                    gNeighbors[countID + gNeighbors[countID]] = i;
                    if (gNeighbors[countID] == gMaxNeighborsCount - 1) {
                        break;
                    }
                }
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float> gLambda;

uniform float gDensity;
uniform float gMass;

#define PI 3.1415927

float Poly6(float3 pDelta, float pRange) {
    float r2 = dot(pDelta, pDelta);
    return 315.0 / (64 * PI * pow(pRange, 9)) * pow((pRange * pRange - r2), 3);
}

float Spiky(float3 pDelta, float pRange) {
    float r = sqrt(dot(pDelta, pDelta));
    return 15 / (PI * pow(pRange, 6)) * pow((pRange - r), 3);
}

#pragma kernel CalculateLambda
[numthreads(MAX_THREAD_X, 1, 1)]
void CalculateLambda(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        

        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePosition
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePosition(uint3 pID : SV_DispatchThreadID) {
    // TODO:
}