RWStructuredBuffer<float3> gPosition;
RWStructuredBuffer<float3> gPredictionPosition;
RWStructuredBuffer<float3> gVelocity;

uniform uint gParticlesNumber;
uniform uint gBlockSize;

#define MAX_THREAD_X 1024
#define DELTA_T  0.01667
#define INV_DELTA_T 60

#pragma kernel ApplyForce
[numthreads(MAX_THREAD_X, 1, 1)]
void ApplyForce(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] += DELTA_T * float3(0, -9.8f, 0);
        gPredictionPosition[id] = gPosition[id] + DELTA_T * gVelocity[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePositionAndVelocity
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePositionAndVelocity(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gPosition[id] = gPredictionPosition[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float3> gWallsNormal;
RWStructuredBuffer<float3> gWallsPosition;

uniform float gRadius;
uniform uint gWallSize;

#pragma kernel HandleCollision
[numthreads(MAX_THREAD_X, 1, 1)]
void HandleCollision(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;

    while (id < gParticlesNumber) {
        for (int i = 0; i < gWallSize; ++i) {
            float3 n = gWallsNormal[i];
            float3 p = gWallsPosition[i];
            float sdf = dot(gPredictionPosition[id] - p, n) - gRadius;
            if (sdf < 0) {
                gPredictionPosition[id] -= sdf * n;
                gVelocity[id] -= (sdf * n) * INV_DELTA_T;
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<int> gGrid;
RWStructuredBuffer<int> gGridCounter;
RWStructuredBuffer<int> gGridEnd;

uniform uint gGirdX;
uniform uint gGridY;
uniform uint gGridZ;
uniform uint gGridSize;
uniform float3 gGridOrigin;
uniform float gKernelRange;

uint Vector3ToUint(uint3 pVec, uint3 pWidth) {
    return pVec.x * 120 + pVec.y * 10 + pVec.z; // TODO
}

uint3 GetGridVector(float3 pPosition, float3 pOrigin, float pRange) {
    uint dx = (uint)floor((pPosition.x - pOrigin.x) / pRange);
    uint dy = (uint)floor((pPosition.y - pOrigin.y) / pRange);
    uint dz = (uint)floor((pPosition.z - pOrigin.z) / pRange);

    return uint3(dx, dy, dz);
}

uint GetGridIndex(float3 pPosition, uint3 pWidth, float3 pOrigin, float pRange) {
    return Vector3ToUint(GetGridVector(pPosition, pOrigin, pRange), pWidth);
} 

#pragma kernel InsertParticlesIntoGrid
[numthreads(MAX_THREAD_X, 1, 1)]
void InsertParticlesIntoGrid(uint3 pID : SV_DispatchThreadID) {
    {
        uint id = pID.x;
        while (id < gGridSize) {
            gGridCounter[id] = 0;
            id += MAX_THREAD_X;
        }
    }

    AllMemoryBarrierWithGroupSync();

    {
        uint id = pID.x;
        while (id < gParticlesNumber) {
            uint gridIndex = GetGridIndex(gPredictionPosition[id], uint3(gGirdX, gGridY, gGridZ), gGridOrigin, gKernelRange);
            InterlockedAdd(gGridCounter[gridIndex], 1);
            id += MAX_THREAD_X;
        }
    }

    AllMemoryBarrierWithGroupSync();

    if (pID.x == 42) {
        for (int i = 1; i < gGridSize; ++i) {
            gGridCounter[i] = gGridCounter[i - 1] + gGridCounter[i];
            gGridEnd[i] = gGridCounter[i];
        }
    }
    AllMemoryBarrierWithGroupSync();

    {
        uint id = pID.x;
        while (id < gParticlesNumber) {
            uint gridIndex = GetGridIndex(gPredictionPosition[id], uint3(gGirdX, gGridY, gGridZ), gGridOrigin, gKernelRange);
            uint index;
            InterlockedAdd(gGridCounter[id], -1, index);
            if (gridIndex > 0) {
                index = index + gGridEnd[gridIndex - 1];
            }

            gGrid[index] = id;
            id += MAX_THREAD_X;
        }
    }
}

RWStructuredBuffer<int> gNeighbors;

uniform uint gMaxNeighborsCount;

#pragma kernel GetNeighbors
[numthreads(MAX_THREAD_X, 1, 1)]
void GetNeighbors(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        int countID = id * gMaxNeighborsCount;
        gNeighbors[countID] = 0;
        for (int i = 0; i < gParticlesNumber; ++i) {
            if (i != id) {
                float3 subVec = gPredictionPosition[i] - gPredictionPosition[id];
                float dis2 = dot(subVec, subVec);
                if (dis2 <= gKernelRange * gKernelRange) {
                    ++gNeighbors[countID];
                    gNeighbors[countID + gNeighbors[countID]] = i;
                    if (gNeighbors[countID] == gMaxNeighborsCount - 1) {
                        break;
                    }
                }
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}