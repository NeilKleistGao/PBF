RWStructuredBuffer<float3> gPosition;
RWStructuredBuffer<float3> gPredictionPosition;
RWStructuredBuffer<float3> gVelocity;

uniform uint gParticlesNumber;
uniform uint gBlockSize;

#define MAX_THREAD_X 1024
#define DELTA_T  0.01667
#define INV_DELTA_T 60

#pragma kernel ApplyForce
[numthreads(MAX_THREAD_X, 1, 1)]
void ApplyForce(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] += DELTA_T * float3(0, -9.8f, 0);
        gPredictionPosition[id] = gPosition[id] + DELTA_T * gVelocity[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePositionAndVelocity
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePositionAndVelocity(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gPosition[id] = gPredictionPosition[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float3> gWallsNormal;
RWStructuredBuffer<float3> gWallsPosition;

uniform float gRadius;
uniform uint gWallSize;

#pragma kernel HandleCollision
[numthreads(MAX_THREAD_X, 1, 1)]
void HandleCollision(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;

    while (id < gParticlesNumber) {
        for (int i = 0; i < gWallSize; ++i) {
            float3 n = gWallsNormal[i];
            float3 p = gWallsPosition[i];
            float sdf = dot(gPredictionPosition[id] - p, n) - gRadius;
            if (sdf < 0) {
                gPredictionPosition[id] -= sdf * n;
                gVelocity[id] -= (sdf * n) * INV_DELTA_T;
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}