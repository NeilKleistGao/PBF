RWStructuredBuffer<float3> gPosition;
RWStructuredBuffer<float3> gPredictionPosition;
RWStructuredBuffer<float3> gVelocity;

uniform uint gParticlesNumber;
uniform uint gBlockSize;

#define MAX_THREAD_X 1024
#define DELTA_T  0.01667
#define INV_DELTA_T 60

#pragma kernel ApplyForce
[numthreads(MAX_THREAD_X, 1, 1)]
void ApplyForce(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] += DELTA_T * float3(0, -9.8f, 0);
        gPredictionPosition[id] = gPosition[id] + DELTA_T * gVelocity[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePositionAndVelocity
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePositionAndVelocity(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gPosition[id] = gPredictionPosition[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float3> gWallsNormal;
RWStructuredBuffer<float3> gWallsPosition;

uniform float gRadius;
uniform uint gWallSize;

#pragma kernel HandleCollision
[numthreads(MAX_THREAD_X, 1, 1)]
void HandleCollision(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;

    while (id < gParticlesNumber) {
        for (int i = 0; i < gWallSize; ++i) {
            float3 n = gWallsNormal[i];
            float3 p = gWallsPosition[i];
            float sdf = dot(gPredictionPosition[id] - p, n) - gRadius;
            if (sdf < 0) {
                gPredictionPosition[id] -= sdf * n;
                gVelocity[id] -= (sdf * n) * INV_DELTA_T;
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<int> gGrid;
RWStructuredBuffer<int> gGridCounter;
RWStructuredBuffer<int> gGridEnd;

uniform uint gGirdX;
uniform uint gGridY;
uniform uint gGridZ;
uniform uint gGridSize;
uniform float3 gGridOrigin;
uniform float gKernelRange;

uint Vector3ToUint(uint3 pVec, uint3 pWidth) {
    return pVec.x * pWidth.y * pWidth.z + pVec.y * pWidth.z + pVec.z;
}

uint3 GetGridVector(float3 pPosition, float3 pOrigin, float pRange) {
    uint dx = (uint)floor((pPosition.x - pOrigin.x) / pRange);
    uint dy = (uint)floor((pPosition.y - pOrigin.y) / pRange);
    uint dz = (uint)floor((pPosition.z - pOrigin.z) / pRange);

    return uint3(dx, dy, dz);
}

uint GetGridIndex(float3 pPosition, uint3 pWidth, float3 pOrigin, float pRange) {
    return Vector3ToUint(GetGridVector(pPosition, pOrigin, pRange), pWidth);
} 

#pragma kernel InsertParticlesIntoGrid
[numthreads(MAX_THREAD_X, 1, 1)]
void InsertParticlesIntoGrid(uint3 pID : SV_DispatchThreadID) {
    {
        uint id = pID.x;
        while (id < gGridSize) {
            gGridCounter[id] = 0;
            id += MAX_THREAD_X;
        }
    }

    AllMemoryBarrierWithGroupSync();

    {
        uint id = pID.x;
        while (id < gParticlesNumber) {
            uint gridIndex = GetGridIndex(gPredictionPosition[id], uint3(gGirdX, gGridY, gGridZ), gGridOrigin, gKernelRange);
            InterlockedAdd(gGridCounter[gridIndex], 1);
            id += MAX_THREAD_X;
        }
    }

    AllMemoryBarrierWithGroupSync();

    if (pID.x == 42) {
        for (int i = 1; i < gGridSize; ++i) {
            gGridCounter[i] = gGridCounter[i - 1] + gGridCounter[i];
            gGridEnd[i] = gGridCounter[i];
        }
    }
    AllMemoryBarrierWithGroupSync();

    {
        uint id = pID.x;
        while (id < gParticlesNumber) {
            uint gridIndex = GetGridIndex(gPredictionPosition[id], uint3(gGirdX, gGridY, gGridZ), gGridOrigin, gKernelRange);
            uint index;
            InterlockedAdd(gGridCounter[id], -1, index);
            if (gridIndex > 0) {
                index = index + gGridEnd[gridIndex - 1];
            }

            gGrid[index] = id;
            id += MAX_THREAD_X;
        }
    }
}

RWStructuredBuffer<int> gNeighbors;

uniform uint gMaxNeighborsCount;

#pragma kernel GetNeighbors
[numthreads(MAX_THREAD_X, 1, 1)]
void GetNeighbors(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gNeighbors[id * gMaxNeighborsCount] = 0;
        uint3 posVec = GetGridVector(gPredictionPosition[id], gGridOrigin, gKernelRange);
        for (int i = -1; i < 2; ++i) {
            if (posVec.x + i < 0) {
                continue;
            }

            for (int j = -1; j < 2; ++j) {
                if (posVec.y + j < 0) {
                    continue;
                }

                for (int k = -1; k < 2; ++k) {
                    if (posVec.z + k < 0) {
                        continue;
                    }
                    
                    uint3 nextVec = uint3(posVec.x + i, posVec.y + j, posVec.z + k);
                    uint nextID = Vector3ToUint(nextVec, uint3(gGirdX, gGridY, gGridZ));

                    int start = 0;
                    if (nextID > 0) {
                        start = gGridEnd[nextID - 1];
                    }
                    
                    for (int m = start; m < gGridEnd[nextID]; ++m) {
                        uint potentialNeighbor = gGrid[m];
                        if (potentialNeighbor != id) {
                            float3 subVec = gPredictionPosition[id] - gPredictionPosition[potentialNeighbor];
                            float dis2 = dot(subVec, subVec);
                            if (dis2 <= gKernelRange * gKernelRange) {
                                ++gNeighbors[id * gMaxNeighborsCount];
                                gNeighbors[id * gMaxNeighborsCount + gNeighbors[id * gMaxNeighborsCount]] = potentialNeighbor;
                                if (gNeighbors[id * gMaxNeighborsCount] == gMaxNeighborsCount - 1) {
                                    i = 2; j = 2; k = 2; m = gGridEnd[nextID];
                                }
                            }
                        }
                        
                    }
                }
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}