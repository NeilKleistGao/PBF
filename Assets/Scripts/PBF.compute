RWStructuredBuffer<float3> gPosition;
RWStructuredBuffer<float3> gPredictionPosition;
RWStructuredBuffer<float3> gVelocity;

uniform uint gParticlesNumber;
uniform uint gBlockSize;

#define MAX_THREAD_X 1024
#define DELTA_T  0.01667
#define INV_DELTA_T 60

#pragma kernel ApplyForce
[numthreads(MAX_THREAD_X, 1, 1)]
void ApplyForce(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] += DELTA_T * float3(0, -9.8f, 0);
        gPredictionPosition[id] = gPosition[id] + DELTA_T * gVelocity[id];

        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePositionAndVelocity
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePositionAndVelocity(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        gVelocity[id] = INV_DELTA_T * (gPredictionPosition[id] - gPosition[id]);
        gPosition[id] = gPredictionPosition[id];
        //TODO:

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float3> gWallsNormal;
RWStructuredBuffer<float3> gWallsPosition;

uniform float gRadius;
uniform uint gWallSize;

#pragma kernel HandleCollision
[numthreads(MAX_THREAD_X, 1, 1)]
void HandleCollision(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;

    while (id < gParticlesNumber) {
        for (int i = 0; i < gWallSize; ++i) {
            float3 n = gWallsNormal[i];
            float3 p = gWallsPosition[i];
            float sdf = dot(gPredictionPosition[id] - p, n) - gRadius;
            if (sdf < 0) {
                gPredictionPosition[id] -= sdf * n;
                gVelocity[id] -= (sdf * n) * INV_DELTA_T;
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<int> gNeighbors;

uniform uint gMaxNeighborsCount;
uniform float gKernelRange;

#pragma kernel GetNeighbors
[numthreads(MAX_THREAD_X, 1, 1)]
void GetNeighbors(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        int countID = id * gMaxNeighborsCount;
        gNeighbors[countID] = 0;
        for (int i = 0; i < gParticlesNumber; ++i) {
            if (i != id) {
                float3 subVec = gPredictionPosition[i] - gPredictionPosition[id];
                float dis2 = dot(subVec, subVec);
                if (dis2 <= gKernelRange * gKernelRange) {
                    ++gNeighbors[countID];
                    gNeighbors[countID + gNeighbors[countID]] = i;
                    if (gNeighbors[countID] == gMaxNeighborsCount - 1) {
                        break;
                    }
                }
            }
        }

        id += MAX_THREAD_X * gBlockSize;
    }
}

RWStructuredBuffer<float> gLambda;

uniform float gDensity;

#define PI 3.1415927

float Poly6(float3 pDelta, float pRange) {
    float r2 = dot(pDelta, pDelta);
    return 315.0f / 64 / PI / pow(pRange, 9) * pow((pRange * pRange - r2), 3);
}

float Poly6Scale(float r2, float pRange) {
    return 315.0f / (64 * PI * pow(pRange, 9)) * pow((pRange * pRange - r2), 3);
}

float3 SpikyGradient(float3 pDelta, float pRange) {
    float r = length(pDelta);
    if (pRange < r) {
        return float3(0, 0, 0);
    }

    float cof = -45.0f / PI / pow(pRange, 6);
    return pow(pRange - r, 2) * cof * normalize(pDelta);
}

#pragma kernel CalculateLambda
[numthreads(MAX_THREAD_X, 1, 1)]
void CalculateLambda(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        float numerator = 0;
        float denomimator = 0;
        int countID = id * gMaxNeighborsCount;
        float3 selfGradient = float3(0, 0, 0);

        for (int i = 0; i < gNeighbors[countID]; ++i) {
            int neighbor = gNeighbors[countID + i + 1];
            float3 selfPosition = gPredictionPosition[id];
            float3 neighborPosition = gPredictionPosition[neighbor];
            float3 sub = selfPosition - neighborPosition;

            numerator += Poly6(sub, gKernelRange);
            float3 nabla = SpikyGradient(sub, gKernelRange) / gDensity;
            denomimator += dot(nabla, nabla);
            selfGradient += nabla;
        }

        numerator = numerator / gDensity - 1;
        denomimator += dot(selfGradient, selfGradient);
        gLambda[id] = -numerator / (denomimator + 100);
        id += MAX_THREAD_X * gBlockSize;
    }
}

#pragma kernel UpdatePosition
[numthreads(MAX_THREAD_X, 1, 1)]
void UpdatePosition(uint3 pID : SV_DispatchThreadID) {
    uint id = pID.x;
    while (id < gParticlesNumber) {
        float3 deltaPos = float3(0, 0, 0);
        int countID = id * gMaxNeighborsCount;
        for (int i = 0; i < gNeighbors[countID]; ++i) {
            int neighbor = gNeighbors[countID + i + 1];
            float3 sub = gPredictionPosition[id] - gPredictionPosition[neighbor];

            // float s = -0.1 * pow(Poly6(sub, gKernelRange) / Poly6Scale(0.1 * gKernelRange, gKernelRange), 4);
            float3 gradient = SpikyGradient(sub, gKernelRange);
            deltaPos += (gLambda[id] + gLambda[neighbor]) * gradient;
        }

        gPredictionPosition[id] += deltaPos / gDensity;
        id += MAX_THREAD_X * gBlockSize;
    }
}